// Copyright 2010-2013 (c) IeAT, Siemens AG, AVANTSSAR and SPaCIoS consortia.
// Licensed under the Apache License, Version 2.0.

/**
 * Visits the tree generated by the parser and registers all symbols into the corresponding entities.
 * By symbols we mean:
 * - variables
 * - constants
 * - functions
 * - macros (they are registered without their bodies for now)
 * - secrecy set symbols (from secrecy and channel goals; they are needed because they can 
 *                        be referred later from code)
 *
 * By the time this grammar is run, the types should have been already registered.
 */
tree grammar SymbolsNew;

options {
	tokenVocab=ASLanPPNew;
	ASTLabelType=CommonTree;
	output=template;
}

@header {
    package org.avantssar.aslanpp;

	import java.util.Map;

	import org.avantssar.commons.*;    
    import org.avantssar.aslanpp.model.*;
    import org.avantssar.commons.ChannelEntry.Type;
}

@members {
	ErrorGatherer err;
	
	//overrides http://www.antlr.org/api/Java/_base_recognizer_8java-source.html#l00189
    public void displayRecognitionError(String[] tokenNames, RecognitionException e)
    {
		err.addError(new LocationInfo(e),
                     ErrorMessages.DEFAULT.PARSER_ERROR, getErrorMessage(e, tokenNames));
    }

	//overrides http://www.antlr.org/api/Java/_base_recognizer_8java-source.html#l00219
	public String getErrorMessage(RecognitionException e, String[] tokenNames)
	{
	    String msg = null;
        if (e instanceof NoViableAltException) { //no viable alternative
            msg = "cannot proceed at input "+getTokenErrorDisplay(e.token);
        }
        else if (e instanceof EarlyExitException) { //required (...)+ loop did not match anything
            msg = "missing at least one occurrence of repeatable element at input "+getTokenErrorDisplay(e.token);
        }
	    else if (e instanceof ASLanPPSyntaxErrorException) {
	    	ASLanPPSyntaxErrorException asee = (ASLanPPSyntaxErrorException)e;
	    	msg = asee.getMessage();
	    }
	    if (msg == null)
	    	msg = super.getErrorMessage(e, tokenNames);
	    return msg;
	}
}

entity[IScope scope]
scope {
	Entity e;
}
@init {
	err = $scope.getErrorGatherer();
}
	: ^(ENTITY UPPERNAME {$entity::e = $scope.findEntity($UPPERNAME.text);} 
			arguments[$entity::e]? declaration[$entity::e]* entity[$entity::e]* body[$entity::e]? constraints[$entity::e]? goals[$entity::e]?) 
	;
	
arguments[Entity e]
	: ^(ARGUMENTS argumentsList[$e]+)
	;
argumentsList[Entity e]
scope {
	List<ISymbol> args;
}
@init {
	$argumentsList::args = new ArrayList<ISymbol>();
}
	: ^(DECLARATION type[$e] 
		^(v=VARS (UPPERNAME
				{VariableSymbol arg = $e.addParameter($UPPERNAME.text, $type.itype, new LocationInfo($v));
				$argumentsList::args.add(arg);
				}
		       )+
		 )
	   )
	   {$e.group($argumentsList::args.toArray(new ISymbol[$argumentsList::args.size()]));}
	;
	
declaration[Entity scope]
	: ^(SYMBOLS symbols[$scope]+)
	| ^(MACROS macro[$scope]+)
	| ^(HORN_CLAUSES .*)
	| ^(EQUATIONS .*)
	;
	
symbols[Entity scope]
	: ^(DECLARATION type[$scope] symbolsList[$scope, $type.itype]) 
	;
symbolsList[Entity scope, IType type]
scope {
	boolean nonPublic;
	boolean nonInvertible;
	List<IType> argTypes;
	List<ISymbol> symbols;
}
@init {
	$symbolsList::nonPublic = false;
	$symbolsList::nonInvertible = false;
	$symbolsList::argTypes = new ArrayList<IType>();
	$symbolsList::symbols = new ArrayList<ISymbol>();
}
	: ^(v=VARS (UPPERNAME {$symbolsList::symbols.add($scope.addStateVariable($UPPERNAME.text, $type, new LocationInfo($v)));})+)
		{$scope.group($symbolsList::symbols.toArray(new ISymbol[$symbolsList::symbols.size()]));}
	| ^(c=CONSTS 
	       (^(FLAGS NONPUBLIC {$symbolsList::nonPublic = true;}))? 
	       (LOWERNAME 
	       		{ConstantSymbol cnst = $scope.constants(new LocationInfo($c), $type, $LOWERNAME.text);
	       		 cnst.setNonPublic($symbolsList::nonPublic);
	       		 $symbolsList::symbols.add(cnst);
	       		}
	       )+
	   )
		{$scope.group($symbolsList::symbols.toArray(new ISymbol[$symbolsList::symbols.size()]));}
	| ^(f=FUNCTION 
	       (^(FLAGS (NONPUBLIC {$symbolsList::nonPublic = true;})? (NONINVERTIBLE {$symbolsList::nonInvertible = true;})?))? 
	       LOWERNAME (at=type[$scope] {$symbolsList::argTypes.add($at.itype);})+
	   )
	       {FunctionSymbol fnc = $scope.addFunction($LOWERNAME.text, $type, $symbolsList::argTypes, new LocationInfo($f));
	       	fnc.setNonPublic($symbolsList::nonPublic);
	       	fnc.setNonInvertible($symbolsList::nonInvertible);
	       }
	;
	
macro[IScope scope]
scope {
	MacroSymbol m;
}
	: ^(MACRO LOWERNAME {$macro::m = $scope.addMacro(new LocationInfo($LOWERNAME.token), $LOWERNAME.text);} (^(ARGS (UPPERNAME {$macro::m.addArgument($UPPERNAME.text);})+))? .)
	;
	
type[IScope scope] returns [IType itype]
scope { List<IType> types; }
@init { $type::types = new ArrayList<IType>(); }
	: LOWERNAME
	  { $itype = $scope.findType($LOWERNAME.text);
	  	if ($itype == null) 
	  		$scope.getErrorGatherer().addException(new LocationInfo($LOWERNAME.token), ErrorMessages.UNDEFINED_TYPE, $LOWERNAME.text); 
	  }
	| ^(TUPLE (t=type[$scope] {$type::types.add($t.itype);})+) 
	  { $itype = new TupleType($type::types); }
	| ^(CONCAT (t=type[$scope] {$type::types.add($t.itype);})+) 
	  { $itype = new TupleType($type::types); }
	| ^(SET t=type[$scope])
	  { $itype = new SetType($t.itype); } 
	| ^(FCALL LOWERNAME (^(ARGS (t=type[$scope] {$type::types.add($t.itype);})+))?)
	  { $itype = new CompoundType(new LocationInfo($LOWERNAME.token), $LOWERNAME.text, $type::types); } 
	;
	
body[Entity e]
	: ^(BODY (^(BREAKPOINTS LOWERNAME+)|UNCOMPRESSED)? stmt[$e])
	;
	
stmts[Entity e]
	:
	(stmt[$e])*
	;
	
stmt[Entity e]
	: assignment[$e]
	| fresh[$e]
	| newEntityInst[$e]
	| symbEntityInst[$e]
	| ifstmt[$e]
	| whilestmt[$e]
	| selectstmt[$e]
	| introducestmt[$e]
	| retractstmt[$e]
	| assertstmt[$e]
	| secrecygoal[$e]
	| ^(BLOCK stmts[$e])
	;
	
assignment[Entity e] : ^(ASSIGNMENT ^(VAR .) ^(TERM .)) ;

fresh[Entity e] : ^(FRESH ^(VAR .)) ;

newEntityInst[Entity e] : ^(NEW ^(ENTITYINST UPPERNAME (^(ARGS .+))? )) ; 	

symbEntityInst[Entity e] : ^(ANY (^(VARS UPPERNAME+))? 
                             ^(ENTITYINST UPPERNAME (^(ARGS .+))?) 
		                     ^(GUARD .*) );
	
ifstmt[Entity e] : ^(IF ^(GUARD .) stmt[$e] (stmt[$e])?);	

whilestmt[Entity e] : ^(WHILE ^(GUARD .) stmt[$e])	;	

selectstmt[Entity e] : ^(SELECT selectOption[$e]+ ) ;

selectOption[Entity e] :  ^(SELECT_OPTION ^(GUARD .) ^(CHANNEL_GOALS channelgoal[$e]*) stmt[$e]) ;

introducestmt[Entity e] : ^(INTRODUCE ^(TERM .) ^(CHANNEL_GOALS channelgoal[$e]*)) ;
 	
channelgoal[Entity e]
	: ^(CHANNEL_GOAL (name=LOWERNAME|name=UPPERNAME) transmission)
		{ if ($transmission.hasSecrecy) {
//			System.out.println("channel goal with secrecy: " + $name.text);
			$e.getSetFunction(ChannelGoal.getSetFunctionName($name.text), Prelude.getSetOf($e.findType(Prelude.AGENT)), new LocationInfo($name));
  		  }
		}
	;
	
retractstmt[Entity e] : ^(RETRACT ^(TERM .)) ;

assertstmt[Entity e] : ^(ASSERT (LOWERNAME|UPPERNAME) ^(GUARD .)) ;
	
secrecygoal[Entity e] : ^(SECRECY_GOAL (name=LOWERNAME|name=UPPERNAME) 
			               ^(KNOWERS .*) ^(PAYLOAD .) )
		{
  		$e.getSetFunction(GenericSecrecyGoal.getSetFunctionName($name.text), Prelude.getSetOf($e.findType(Prelude.AGENT)), new LocationInfo($name)); 
		}
	;
	
transmission returns [boolean hasSecrecy]
	: ^(TRANSMISSION_ANN ^(CHANNEL . tp=. .) .)
	{
		ChannelEntry ce = ChannelEntry.getByKey($tp.getText(), false);
		$hasSecrecy = (ce.type == ChannelEntry.Type.Confidential) || (ce.type == ChannelEntry.Type.Secure);
	} 
	| ^(TRANSMISSION_ANN ^(CHANNEL_NAMED . tp=. .) .)
	{
		$hasSecrecy = false;
	}
	;
	
constraints[Entity e]
	: ^(CONSTRAINTS constraint[$e]+)
	;

constraint[Entity e]
	: ^(CONSTRAINT . .)
	;	

goals[Entity e]
	: ^(GOALS goal[$e]+)
	;

goal[Entity e]
	: ^(INVARIANT_GOAL . .)
	| ^(SESSION_CHANNEL_GOAL (name=LOWERNAME|name=UPPERNAME) ^(CHANNEL . tp=. .))
      {
		ChannelEntry ce = ChannelEntry.getByKey($tp.getText(), false);
		boolean hasSecrecy = (ce.type == ChannelEntry.Type.Confidential) || (ce.type == ChannelEntry.Type.Secure);
		if (hasSecrecy)
			$e.getSetFunction(ChannelGoal.getSetFunctionName($name.text), Prelude.getSetOf($e.findType(Prelude.AGENT)), new LocationInfo($name));
	  } 
	| ^(SESSION_SECRECY_GOAL (name=LOWERNAME|name=UPPERNAME) .)
	  {
  		$e.getSetFunction(GenericSecrecyGoal.getSetFunctionName($name.text), Prelude.getSetOf($e.findType(Prelude.AGENT)), new LocationInfo($name)); 
	  }
	;	
