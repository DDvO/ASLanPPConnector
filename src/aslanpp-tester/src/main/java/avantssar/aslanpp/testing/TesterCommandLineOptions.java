// Copyright 2010-2013 (c) IeAT, Siemens AG, AVANTSSAR and SPaCIoS consortia.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package avantssar.aslanpp.testing;

import java.io.File;
import java.io.PrintStream;
import java.net.URL;
import org.avantssar.commons.TranslatorOptions;
import org.kohsuke.args4j.Argument;
import org.kohsuke.args4j.CmdLineException;
import org.kohsuke.args4j.CmdLineParser;
import org.kohsuke.args4j.Option;

public class TesterCommandLineOptions extends TranslatorOptions {

	private static String JAR_FILE = "aslanpp-tester.jar";

	private static CmdLineParser parser;

	public TesterCommandLineOptions() {
		parser = new CmdLineParser(this);
		loadJarName();
	}

	public CmdLineParser getParser() {
		return parser;
	}

	@Option(name = "-h", aliases = "--help", usage = "Show help.")
	private boolean showHelp;

	@Option(name = "-v", aliases = "--version", usage = "Display version information.")
	private boolean showVersion;

	@Option(name = "-o", aliases = "--output", metaVar = "OUTPUT_DIR", usage = "The directory where to write the output files. Output files means: the original ASLan++ specifications, the translated ASLan specifications, text files with the errors and/or warnings generated by the translator and text files with the output generated by the backends.")
	private File out;

	@Argument(metaVar = "INPUT_DIR", usage = "The root of the directory tree that will be scanned for ASLan++ specifications. Every ASLan++ specification that will be found will be translated to ASLan and then the configured backends will be invoked for analyzing the obtained ASLan specification.")
	private File in;

	@Option(name = "-l", aliases = "--library", usage = "Verify the internal library of programatically built specifications.")
	private boolean library;

	@Option(name = "-tn", aliases = "--threads-number", usage = "Number of threads to launch in parallel.")
	private int threads;

	public boolean isShowHelp() {
		return showHelp;
	}

	public void setShowHelp(boolean showHelp) {
		this.showHelp = showHelp;
	}

	public boolean isShowVersion() {
		return showVersion;
	}

	public void setShowVersion(boolean showVersion) {
		this.showVersion = showVersion;
	}

	public File getOut() {
		return out;
	}

	public void setOut(File out) {
		this.out = out;
	}

	public File getIn() {
		return in;
	}

	public void setIn(File in) throws CmdLineException {
		this.in = in;
	}

	public boolean isLibrary() {
		return library;
	}

	public void setLibrary(boolean library) {
		this.library = library;
	}

	public int getThreads() {
		return threads;
	}

	public void setThreads(int threads) {
		this.threads = threads;
	}

	public void ckeckAtEnd() throws CmdLineException {
		if (showHelp || showVersion) {
			return;
		}
		if (in == null && !isLibrary()) {
			throw new CmdLineException(parser, "You must specify an input directory, or choose the internal library for analysis.");
		}
		if (in != null && isLibrary()) {
			throw new CmdLineException(parser, "You can check either a directory on disk, either the internal library, not both in the same time.");
		}
		if (in != null && (!in.exists() || !in.isDirectory())) {
			throw new CmdLineException(parser, "The specified input directory cannot be accessed or is not a directory.");
		}
		if (out == null) {
			throw new CmdLineException(parser, "You must specify an output directory.");
		}
		if (!out.exists() || !out.isDirectory()) {
			throw new CmdLineException(parser, "The specified output directory cannot be accessed or is not a directory.");
		}
		if (isPrettyPrint()) {
			System.out.println("Sorry, but we don't pretty-print during testing.");
			setPrettyPrint(false);
		}
		if (isPreprocess()) {
			System.out.println("Sorry, but we don't just preprocess during testing.");
			setPreprocess(false);
		}
		// if (isUseBangOperator()) {
		// System.out.println("Sorry, but we don't use the bang '!' operator during testing.");
		// setUseBangOperator(false);
		// }
		if (getOrchestrationClient() != null) {
			System.out.println("Sorry, but we don't do orchestration during testing.");
			setOrchestrationClient(null);
		}
	}

	public void showShortHelp(PrintStream out) {
		showSingleLineUsage(out);
		out.println("Run the program with the -h or --help option for details about available options.");
	}

	public void showLongHelp(PrintStream out) {
		showSingleLineUsage(out);
		out.println("Available options:");
		out.println();
		parser.printUsage(out);
		out.println();
		out.println();
	}

	public void showSingleLineUsage(PrintStream out) {
		out.print("Usage: java -jar ");
		out.print(TesterCommandLineOptions.JAR_FILE);
		parser.printSingleLineUsage(out);
		out.println();
		out.println();
	}

	private void loadJarName() {
		String pathToOurSpecificResource = Tester.class.getCanonicalName();
		pathToOurSpecificResource = "/" + pathToOurSpecificResource.replace('.', '/') + ".class";
		URL u = Tester.class.getResource(pathToOurSpecificResource);
		if (u.getFile().indexOf("!") > -1) {
			String[] parts = u.getFile().split("!");
			File f = new File(parts[0].substring(parts[0].indexOf(":") + 1));
			JAR_FILE = f.getName();
		}
	}
}
